### LinkedList 集合的底层原理

基于双链表实现的。

#### 链表

![](https://raw.githubusercontent.com/tianran721/img/main/img/20240113094840.png)

那么链表呢它是由一个一个所谓的节  
点组成的

这些节点在内存中它不是连续存储的  
它跟数组不一样  
数组的数据是连续存储的  
链表的数据它是分散存储的  
但是链表的每个节点它除了会包含数  
据值之外  
它还会包含下一个节点的地址信息  
通过这个地址信息  
我们是可以去找到下一个节点的  
这样就实现了一个节点链接一个节点  
的形式  
这个就是所谓的链表啊

链表中的结点是独立的对象，在内存中是不连续的，每个结点包含数据值和下一个结点的地址。

以添加数据为例啊  
那么当我们添加第一个数据 a 的时候  
那么这个 a 数据就被称之为头节点  
大家注意了  
链表的头节点它本身的地址是会被记  
住的  
到时候我们就可以通过这个地址找到  
头节点

那接着我们再添加第二个数据  
比如说是 b 这个数据的时候呢  
那 b 这个数据它会有自己的一个地址  
假如说这个地址是 11  
然后他会把自己的地址呢交给头节点  
a 来记住  
那大家看 a 这个头节点  
是不是就指向了 b 这个节点呢

![](https://raw.githubusercontent.com/tianran721/img/main/img/20240113095210.png)

![](https://raw.githubusercontent.com/tianran721/img/main/img/20240113095241.png)

这样就形成了一个链表  
到时候我们就可以从头节点这里去  
依次找到这每一个数据了啊

链表的特点 1：查询慢，无论查询哪个数据都要从头开始找。

 链表它本身也是有索引的  
比如说我现在说要找到第二个索引  
处的数据  
你能够马上去找到第二个索引位置处  
吗  
你肯定不能  
因为它的元素在内存中  
它不是连续的

所以他这里说的查询慢  
不光是查数据慢  
而且是根据索引去定位数据的时候  
也要从头到尾的开始找

链表的特点 2：链表增删相对快

#### 在数据 BD 之间添加一个数据 C

![](https://raw.githubusercontent.com/tianran721/img/main/img/20240113095912.png)

他把 c 放在内存的任何一个位置  
比如说它的位置是 54  
接着他只需要是让 c 这个数据的  
它的下个地址呢去指向 d  
你看这里是 37  
然后呢让 b 对应的下一个数据的地址  
也就是让 b 它的下一个地址呢  
比如说变成 54 来指向 c  
这样是不是就把 c 添加进去了

因为它的元素在内存中都是分散存储  
的  
无论你加多少数据  
它都不存在扩容  
它也不需要原来那些元素的位置  
所以它添加数据的速度肯定是比较快  
的

#### 删除数据 CE 之间的数据 D

他只需要把数据 c 对应的下一个  
地址值  
指向 E  
也就是让 c 去指向 e 就行了  
这个地址是 96  
然后大家注意了  
他直接把这个数据 d 干掉就完了  
就是把这个数据 d 从中间抹掉就行了

![](https://raw.githubusercontent.com/tianran721/img/main/img/20240113100227.png)

那同学们注意看人家删除中间某一  
数据  
是不是也只需要改一改这些地址值就  
行了  
他不需要去迁移其他元素的位置  
原来我们用数组删除某一个数据的时  
候  
可能要把后面的数据挨个往前挪  
但是人家这里呢是不需要的

#### 单向链表

那这里说的链表呢  
其实以后我们会把它称之为单向链表  
也就是说它是从头节点这样挨个的往  
后找的  
它不能够从后往前找啊  
这叫单向链表

![](https://raw.githubusercontent.com/tianran721/img/main/img/20240113100547.png)

#### 双向链表

![](https://raw.githubusercontent.com/tianran721/img/main/img/20240113100629.png)

它指的是你可以从头节点这里开始  
挨个的往后找  
他每个节点会记下个节点的地址  
可以从前往后找  
同时呢它每一个节点呢也会记前一个  
节点地址  
也就是说你又可以从尾节点这里从后  
往前找  
这就叫双向链表

在 java 中大多情况下都会使用双向链表啊

特点：查询慢，增删相对较快，但对首尾元素进行增删改查的速度是极快的。

而双向链表它可以做一个判断  
它可以判断当前这个索引是靠前一些  
还是靠后一些  
如果当前要找到这个索引靠前一些  
它就可以从前往后找  
如果当前要找到这个索引靠后一些  
它就可以从后往前找  
这样是不是可以更快的找到数据啊

==有一个重点来了==  
==我们双向链表==  
==它最大的优点是对首尾元素进行增删==  
==改查的速度是极快的==

因为双向链表啊  
它实际上是有一个头节点地址  
和一个尾节点地址的  
通过这个头节点地址和尾节点地址  
可以快速的找到第一个数据  
也可以快速的找到最后一个数据  
那我在头和尾这个地方  
由于我可以快速的找到  
那我在头和尾进行增删速度肯定是极  
快的

LinkedList 新增了：很多首尾操作的特有方法。

这是因为 java 知道 link list 是基于双链表  
对首尾数据进行操作的  
性能是极好的  
因此 java 就为 link list 新增了很多  
首尾操作的特有方法出来  
以方便程序员使用好

```
public void addFirst(E e)
在该列表开头插入指定的元素
public void addLast(E e)
将指定的元素追加到此列表的末尾
public E getFirst()
返回此列表中的第一个元素
public E getLast()
返回此列表中的最后一个元素
public E removeFirst()
从此列表中删除并返回第一个元素
public E removeLast()
从此列表中删除并返回最后一个元素
```

#### LinkedList 的应用场景之一：可以用来设计队列

队列的特点：先进先出，后进后出

我们经常遇到的一些叫号系统  
或者一些排队系统  
它的后台其实就是用队列实现的啊

队列它其实就是在频繁的操作首尾数  
据的  
比如说他经常要往尾部添加新的数据  
进来排队  
然后从头部把数据取出来  
代表出队呀  
并且呢队列还要记录这个添加数据的  
顺序

然后这个时候你就不要再去用多态写  
代码了  
因为多态的形式写的话  
list 它并没有那些首尾操作的特有方  
法  
是 link list  
基于双链表  
人家提供了一些特有方法

```

LinkedList<String> queue = new LinkedList<>() 


queue.addLast（e：＂第1号人＂) 
 
 

queue.addLast（e：＂第2号人＂) 
 
 

queue.addLast（e：＂第3号人＂) 
 
 
 
queue.addLast（e：＂第4号人＂) 
 
 
 System.out.println(queue) 

 
 //出队
System.out.println(queue.removeFirst()) 

System.out.println(queue.removeFirst()) 
 
System.out.println(queue.removeFirst()) 

```

#### LinkedList 的应用场景之一：可以用来设计栈

栈的特点：后进先出，先进后出

大家注意看这个站呢它一端是开口的  
而另一端呢它是封闭的啊  
开口的称之为栈顶  
那另一端呢称之为这个栈底好

数据进入栈模型的过程称为：压／进栈（push)  
![](https://raw.githubusercontent.com/tianran721/img/main/img/20240113105307.png)

数据离开栈模型的过程称为：弹／出栈（pop)

我们可以用栈来设计手枪的弹夹

比如说你要开发游戏的时候  
你要去描述每一颗子弹的这个打出情  
况  
那么你就应该创建一个对象来代表栈  
用这个站栈记这个子弹

只是在首部增删元素，用 LinkedList 来实现很合适

```
//2,创建一个栈对象。
LinkedList<String> stack = new LinkedList<>() 
 
 //压栈
stack.addFirst（＂第1颗子弹＂) 
 
stack.addFirst（＂第2颗子弹＂) 
 
stack.addFirst（＂第3颗子弹＂) 
 
stack.addFirst（＂第4颗子弹＂) 


//出栈
System.out.println(stack.removeFirst()) 

System.out.println(stack.removeFirst()) 
 

System.out.println(stack) 
 

```

```
public void bush(E e) { 
	addFirst(e) 
 
 
 
 
 

}

----
//压栈（push)
stack.push（＂第1颗子弹＂) 
 
 


//出栈（pop)
System.out.println(stack.pob()) 
 
 
 
 
 


```
