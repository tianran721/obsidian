# 05.认识异常,自定义异常

方法出现异常  
这个方法的内部就会把这个问题的信息  
封装成一个的异常对象  
从**main 方法抛出去**啊  
他会抛给我们的**jvm 虚拟机**  
jvm 收到你的这个**异常对象**之后  
他会把你的程序先停下来  
再把这个异常对象打印出来给你看

**整数不能除以 0**  
![](https://raw.githubusercontent.com/tianran721/img/main/img/20240110225447.png)

**异常的体系**

![](https://raw.githubusercontent.com/tianran721/img/main/img/20240110225548.png)

Error：代表的系统级别错误（属于严重问题)，也就是说系统一旦出现问题， sun 公司会把这些问题封装成 Error 对象给出来，  
说白了， Error 是给 sun 公司自己用的，不是给我们程序员用的，因此我们开发人员不用管它。

程序员通常会用**Exception 以及它的子类**来封装程序出现的问题。

**运行时异常**：RuntimeException 及其子类，编译阶段不会出现错误提醒，运行时出现的异常（如：数组索引越界异常)

同学们在开发中呢要尽量避免出现运营事  
异常出现了  
就是你的水平有问题

**编译时异常**：编译阶段 (**写代码时**) 就会出现错误提醒的。（如：日期解析异常)

## 编译时异常 2 种方式解决

### try catch

![](https://raw.githubusercontent.com/tianran721/img/main/img/20240111001706.png)

直接捕获程序出现的异常

try 就是用来监视你这段程序会不会出异常  
而这个 catch 呢代表的是捕获的意思  
一旦你的程序真的出现了异常  
他会把这个异常对象抓住  
交给这个解析异常的变量 e  
再通过调异常对象的这个方法  
把异常的信息呢打印出来  
![](https://raw.githubusercontent.com/tianran721/img/main/img/20240111000616.png)

### throws 抛出异常

![](https://raw.githubusercontent.com/tianran721/img/main/img/20240111001650.png)

jvm 他知道如何处理你的异常吗  
你的问题他当然不知道怎么处理啊  
所以 jvm 最终呢他也会在内部用一个 try catch  
把你的异常呢给抓住  
然后呢在我们的控制台打印这个异常对象的信息  
就完事儿了  
这也就是为什么我们之前在控制台  
能够看到一堆异常信息的原因啊

## 自定义异常

Java 无法为这个世界上全部的问题都提供异常类来代表，如果企业自己的某种问题，想通过异常来表示，以便用异常来管理该问题，那就需要自己来定义异常类了。

当程序出现的问题  
这样去输出  
比如说年龄非法  
如果你是直接这样输出的话  
是非常不专业的

比如说我是上层的调用者啊  
他调了这个方法  
然后传的非法数据  
那上层调用者如果想知道底层这个方法的执行  
是执行成功了还是执行失败了  
那此时上层调用者是不能够知道的

因为当前这个方法它是**无返回值类型**的方法呀  
遇到这样的业务问题  
我一定要通知上层调用者  
底层方法的执行情况

此时啊正确的做法  
你应该用一个异常对象来封装这个问题  
我们可以通过抛出这个异常对象  
给上层的调用者  
调者就知道了底层这个方法到底是执行成功还是执行失败了

同时呢这个异常对象它也封装了该问题的信息  
比如说哪里出现的这个问题  
是什么原因导致的  
这样也方便我们去定位这个问题啊

但是由于年龄非法这个问题  
java 并没有涉及异常类来代表  
遇到这样的问题  
我们就可以自定义异常类  
来代表并封装这个问题了

## **自定义异常的种类**

自定义运行时异常:

定义一个异常类**继承 RuntimeException.**  
重写构造器。gene-constructor (一般选择前两个)

通过 throw new 异常类（xxx) 来创建异常对象并抛出。 (提醒不强烈，运行时才可能出现！！)

出去这个异常对象抛到哪里去呢  
抛到这个方法的入口,再抛给他的调用者

调用者再通过 try catch 捕获这个异常  
打印栈信息  
![](https://raw.githubusercontent.com/tianran721/img/main/img/20240111003439.png)

自定义编译时异常:

定义一个异常类**继承 Exception**.  
重写构造器。  
通过 throw new 异常类（xxx) 来创建异常对象并 throws xxxException 往上抛出给调用者。  
然后继续抛或 try catch (编译阶段就报错，提醒更加强烈！)

throw 抛出异常对象  
throws 用在方法上，抛出方法内部的异常

如果说你这个问题呢特别严重  
程序员很容易犯  
你想非常强烈的去提醒程序员注意  
你就应该抛一个编译时异常  
那这样的好处是比如说程序员呢他不注意的话  
他写完就会报错  
就会强烈提醒他要检查对吧

# 06.异常的两种处理方式

**开发中对于异常的常见处理方式**

1.一般会在**最外层捕获异常**(别抛了),给用户一个非常友好的提示

这异常信息直接抛给用户,用户体验不好

![](https://raw.githubusercontent.com/tianran721/img/main/img/20240111004616.png)

他捕获完这些异常之后  
他可以把这些异常信息呢给记录起来  
比如说记录到文件中去  
方便程序员下次来查看这些异常信息  
定位系统的问题  
然后呢再把这个系统代码进行更改  
打一些补丁  
这样你的系统就会变得越来越健壮

其实我们是可以在 catch 内部呢  
比如说先响应一个消息给用户模拟一下  
比如说我们就响应一个您要找的文件不存在对吧  
相当于给用户一个友好提示

## 异常优化

那么在实际开发时候呢  
很多时候我们不建议同学们去抛它具体的异常  
因为这内部到底有什么异常你也不知道对吧  
你就直接抛 Exception 就行了  
由于 exception 异常是 java 中所有异常的祖宗类

你直接 catch 拦截一个 Exception 异常

### 捕获异常，尝试重新修复

需求：调用一个方法，让用户输入一个合适的价格返回为止。

价格是小数 double

就是你现在没有办法控制用户  
用户它可能会随便乱输入东西  
导致出异常

只要有异常上来就捕获它  
一旦捕到异常之后  
我们就知道一定是用户输入的这个价格是在瞎搞啊  
到这来被拦截住啊  
那我就可以在这个地方尝试修复

![600](https://raw.githubusercontent.com/tianran721/img/main/img/20240111021554.png)

我可以把这段代码  
是不是再放到一个**while 死循环**里面去啊  
拦截到这个非法异常  
我就尝试修复嘛  
这个 while 死循环就是尝试修复它  
就会再次调这个方法  
直到成功为止,我们就**调 break**是跳出这个循环  
那现在我这个系统就非常健壮了
