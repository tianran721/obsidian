## 抽象类

![](https://raw.githubusercontent.com/tianran721/img/main/img/20240109012047.png)

抽象类

不一定有抽象方法

### 抽象方法 

只有签名

不能写方法体

有抽象方法的类一定设成抽象类

抽象类不能实例化对象:

如果我用 a 调用抽象类的 run 方法  
这个 run 方法是不是一脸懵逼啊  
因为它连方法体都没有

### 抽象类作用

作为一种特殊的父类让子类继承并实现

一个类如果继承抽象类，必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类。

定义抽象类的好处: 子类继承抽象 更好的支持多态

父类知道每个子类都要做某个行为，但每个子类要做的情况不一样，父类就定义成抽象方法，交给子类去重写实现

可以通过父类调方法走子类的行为

### 使用多态的好处

1. 多态形式下，右边对象是解/松耦合的，更便于扩展和维护。

↓

如果将来 Teacher 要换成 Student , 可以随时切换为 Student 对象, 后面的代码不受影响 (松耦合)

2. 定义方法时，可以使用父类类型做形参，方法调用时可以接收一切子类

多态的问题

多态下不能调用子类的独有功能 (方法)。 原因是编译时 (写代码时),编译器会看父类,找不到子类的独有方法,导致报错

↓

### 多态下的类型转换问题

#### 自动类型转换

父类变量名 = new 子类（)

#### 强制类型转换

子类 变量名 = （子类) 父类变量

存在继承／实现关系就可以在编译阶段进行强制类型转换，编译阶段不会报错。

运行时，如果发现对象的真实类型与强转后的类型不同，就会报类型转换异常（ClassCastException)

强制类型转换前,使用 instanceof 关键字，判断当前对象的真实类型，再进行强转:

p instance Student 格式：

## 4.抽象类的常见应用场景：模板方法设计模式

模板方法设计模式

解决方法中存在重复代码的问题。

1,定义一个抽象类。

2,在里面定义 2 个方法

一个是模板方法：把相同代码 抽象方法放里面

一个是抽象方法：具体实现交给子类完成。

t : 表示制表符 ,输出空格

建议使用 final 关键字修饰模板方法 : 防止修改